var CURVE_POINTS_SEPERATION=3;define(["curves/Curve"],(function(e){return class{constructor(r){e.call(this,r),this.ncurve=0,this.startAngle=0,this.endAngle=0}init(r){this.ncurve=Math.floor(this.hitObject.pixelLength/CURVE_POINTS_SEPERATION)+1,this.curve=[];var t=0,i=0,s=0,c=r[0],n=c.curve[0],v=0,h=this.hitObject.pixelLength;h<0&&console.error("osu curve: negative slider length");for(var u=0;u<=this.ncurve;u++){for(var l=u*h/this.ncurve;t<l;){if(v=t,n=c.curve[i],++i>=c.ncurve)if(s<r.length-1)c=r[++s],i=0;else if(i=c.ncurve-1,v===t){t<.97*h&&console.warn("[curve] L/B shorter than given",t/h);break}t+=c.curveDistance[i]}var a=c.curve[i];if(n==a)this.curve[u]=a;else{const r=.001;if(Math.abs(t-v)<r)this.curve[u]={x:(n.x+a.x)/2,y:(n.y+a.y)/2,t:u/this.ncurve};else{let r=(l-v)/(t-v);this.curve[u]={x:e.lerp(n.x,a.x,r),y:e.lerp(n.y,a.y,r)},this.curve[u].t=u/this.ncurve}}}}pointAt(r){var t=r*this.ncurve,i=Math.floor(t);if(i>=this.ncurve)return this.curve[this.ncurve];{let r=this.curve[i],s=this.curve[i+1],c=t-i;return{x:e.lerp(r.x,s.x,c),y:e.lerp(r.y,s.y,c)}}}}}));